一个布尔类型的值只有两种：true 或 false。if 和 for 语句的条件部分都是布尔类型的值，并且==和<等比较操作也会产生布尔型的值。

一元操作符!对应逻辑非操作，因此!true的值为 false，更复杂一些的写法是(!true==false) ==true，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示x==true。

```go
var aVar = 10 
aVar == 5  // false
aVar == 10 // true 
aVar != 5  // true
aVar != 10 // false
```

Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：

```go
s != "" && s[0] == 'x'
```

其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

因为&&的优先级比||高（&& 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：

```go
if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {
  // ...ASCII字母或数字... 
}
```

布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：

```go
i := 0 
if b {
  i = 1 
}
```

如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：

```go
// 如果b为真，btoi返回1；如果为假，btoi返回0 
func btoi(b bool) int {
  if b {
    return 1
  }
  return 0
}
```

数字到布尔型的逆转换非常简单, 不过为了保持对称, 我们也可以封装一个函数：

```go
// itob报告是否为非零。 
func itob(i int) bool {
  return i != 0 
}
```

Go语言中不允许将整型强制转换为布尔型，代码如下：

```go
var n bool 
fmt.Println(int(n) * 2)
```

编译错误，输出如下：

```go
cannot convert n (type bool) to type int 
```

布尔型无法参与数值运算，也无法与其他类型进行转换。